## 正規表現

# 正規表現オブジェクト
regex = /hello, world/

# リテラル
# 正規表現によってマッチさせたい文字列そのもの

# メタ文字
# 正規表現内で特殊な働きをする文字列

# メタ文字の一覧
( ) [ ] { } . ? + * | \

# 「.」 => 改行以外の任意の1文字にマッチするワイルドカード
# 「\」 => メタ文字をリテラルとして扱いたい場合は直前に「\」を付けてエスケープする、option+¥


# 文字列をn文字ずつの配列に分割する => scan
# scanメソッド自身は、引数のパターンを繰り返しマッチし、マッチした部分文字列を配列として返す
# これを利用して、ワイルドカードが1回以上2回以下のパターンを指定することで文字列を分割する
str = 'hello, world'
str.scan(/.{1,2}/) #=> ["he", "ll", "o,", " w", "or", "ld"]
# 分割した文字列をブロックに渡して、2文字目のみ出力する
str.scan(/.{1,2}/) do |substr|
  p substr[1] #=> "e", "l", ...
end

# 文字列内に特定のパターンの部分文字列を含むを正規表現を使って調べる　=> match
# 戻り値はMatchDataオブジェクト、何も指定しないと一致した部分文字列を返す

# キャプチャ
# 例. 同じ文字が4回連続している箇所があるかを調べる
# 丸括弧「()」で指定した部分文字列によるキャプチャを行い、キャプチャした文字列は後ろの「\1」で参照することができる
# 同じ文字が4回連続 = キャプチャした文字がその後3回続いているかを調べる
str = 'aabbbbccddefff'
p str.match(/([a-z]\1{3})/) #=> #<MatchData "bbbb" 1:"b"> # キャプチャした文字列はインデックス番号1で参照可能
